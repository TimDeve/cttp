(load "src/deps.carp")

(load "src/models.carp")
(load "src/void.carp")
(load "src/thread.carp")
(load "src/res.carp")
(load "src/req.carp")
(load "src/static.carp")

(use Socket)

(defmodule Unsafe
  (defn unsafe-deref [r]
    (Pointer.to-value
      (the (Ptr a)
           (Unsafe.coerce (the (Ref a) r))))))

(defmodule Koi
  (sig not-found (Fn [Req] Res))
  (defn not-found [req]
    (Res.send (HttpStatus.NotFound)
              @"text/html"
              @"<h1>Not Found</h1>"))

  (sig internal-server-error (Fn [Req] Res))
  (defn internal-server-error [req]
    (Res.send (HttpStatus.InternalServerError)
              @"text/html"
              @"<h1>Internal Server Error</h1>"))

  (sig bad-request (Fn [] Res))
  (defn bad-request []
    (Res.send (HttpStatus.BadRequest)
              @"text/plain"
              @"Bad Request"))

  (hidden get-handler-from-routes)
  (private get-handler-from-routes)
  (sig get-handler-from-routes (Fn [(Ref Req) (Ref (Array Route))] (Fn [Req] Res)))
  (defn get-handler-from-routes [req routes]
    (let [verb @(Req.verb req)
          path (URI.str (Req.uri req))]
     (match (Array.find
             &(fn [route]
               (and
                (= &verb (Route.verb route))
                (= &path (Route.path route))))
             routes)
      (Maybe.Just route) @(Route.handler &route)
      (Maybe.Nothing)    not-found)))

  (hidden get-res-from-routes)
  (private get-res-from-routes)
  (sig get-res-from-routes (Fn [String (Ref (Array Route))] Res))
  (defn get-res-from-routes [req-str routes]
    (match (Req.parse &req-str)
      (Result.Success req) ((get-handler-from-routes &req routes) req)
      (Result.Error _)     (bad-request)))

  (hidden print-registered-routes)
  (private print-registered-routes)
  (sig print-registered-routes (Fn [&(Array Route)] ()))
  (defn print-registered-routes [routes]
    (do
      (println* "Registered routes:")
      (foreach [route routes]
       (println* route))))

  (defn-do serve-client [pool]
    (while true
      (do
        (void (Mutex.lock (Pool.mutex pool)))
        (if (> (Array.length (Pool.clients pool)) 0)
          (let-do [client (Array.pop-back! (Pool.clients pool))
                   routes (Pool.routes pool)
                   sock (Unsafe.unsafe-deref (Client.sock &client))
                   _ (Unsafe.leak client)]
            (void (Mutex.unlock (Pool.mutex pool)))
            (let-do [req (read &sock)]
              (println* &(fmt "---REQUEST---\n%s" &req))
              (send &sock &(let-do [res     (get-res-from-routes req routes)
                                    res-str (Res.str &res)]
                             (println* &(fmt "---RESPONSE---\n%s" &res-str))
                             res-str)))
            (Socket.close sock))
          (do
            (void (Mutex.unlock (Pool.mutex pool)))
            (System.sleep-micros 100))))))

  (sig serve (Fn [(Ref String) Int (Array Route)] ()))
  (defn-do serve [ip port routes]
    (print-registered-routes &routes)
    (Socket.with-server server ip port
      (let-do  [pool (Pool.init (Mutex.init) [] routes)
                one (Thread.create &(Thread.init) NULL &serve-client &pool)
                two (Thread.create &(Thread.init) NULL &serve-client &pool)
                three (Thread.create &(Thread.init) NULL &serve-client &pool)
                four (Thread.create &(Thread.init) NULL &serve-client &pool)]
        (listen &server)
        (println* (fmt "Listening on %s:%i" ip port))
        (while true
         (let-do [client (accept &server)]
          (void (Mutex.lock (Pool.mutex &pool)))
          (Array.push-back! (Pool.clients &pool) (Client.init client))
          (void (Mutex.unlock (Pool.mutex &pool)))))))))
